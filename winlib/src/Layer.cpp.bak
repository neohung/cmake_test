#include <stdio.h>
//#include <main.h>
//#include <testapi.h>
//#include <tcimg.h>

#include <winapi.h>
#include <SDL.h>
#include <assert.h>
Layer::Layer()
{
}

Layer::~Layer()
{
}

void Layer::update()
{
 int i;
 for(i=0;i<components.size();i++){
  components[i]->draw(pixelbuf);
 }
 for(i=0;i<components3D.size();i++){
  update_perspective_projection(components3D[i]);
  components3D[i]->draw(pixelbuf);
 }
}

void Layer::update_perspective_projection(DrawBase3D* db3)
{
  int cx = camera.x();
  int cy =  camera.y();
  int cz =  camera.z(); //pixels
  int i;
  db3->v2d.clear();
  for(i=0;i<db3->v.size();i++){
    int xp = db3->v[i].x();
    int yp = db3->v[i].y();
    int zp = db3->v[i].z();
    int zdenom = (zp + cz);
    float xs = (cx + (((xp-cx) * cz ) / zdenom));
    float ys = (cy - (((yp-cy) * cz )/ zdenom));
    Position2D p = Position2D(xs,ys);
    db3->v2d.push_back(p);
  }
}

void Layer::setPos(unsigned short x, unsigned short y)
{
  PosX = x;
  PosY = y;
}

void Layer::setPos(Position2D p)
{
  PosX = p.x();
  PosY = p.y();
}

Layer::Layer(const char* name, unsigned short x, unsigned short y, unsigned short w, unsigned short h,unsigned int color):
PosX(x), PosY(y), Width(w), Height(h), IsSkip(false),order(255)
{
   Name = (char*)name;
   pixelbuf = createPixelBuffer(Width,Height, 24);
   memset(pixelbuf->pixels,color,pixelbuf->size);
   //
   camera.setCamera(Position3D(Width/2.0,Height/2.0,640), 0);
}

void Layer::setPixel(int x, int y,int color)
{
  if ((x < 0) || (x > Width) || (y<0) || (y>Height)) 
    return;
  unsigned char b = 0x0000ff & color;
  unsigned char g = (0x00ff00 & color) >> 8;
  unsigned char r = (0xff0000 & color) >> 16;
  unsigned char a = (0xff000000 & color) >> 24;
  unsigned char* offset = (unsigned char*)pixelbuf->pixels + (y *  pixelbuf->bytesperline) + (pixelbuf->colors*x);
  *offset = b;
  *(offset+1) = g; //G
  *(offset+2) = r; //R
}

void Layer::clearDraw()
{
	memset(pixelbuf->pixels,0,pixelbuf->size);
}

DrawBase* Layer::add(DrawBase* db)
{
  components.push_back(db);
  return db;
}

DrawBase3D* Layer::add(DrawBase3D* db)
{
  components3D.push_back(db);
  return db;
}
//====================

void DrawBase::findBound(Position2D* p, PFLOAT* w, PFLOAT* h)
{
  //Do sorting
  std::vector<Position2D> xsort_vector;
  std::vector<Position2D> ysort_vector;
  xsort_vector.assign(v.begin(), v.end());
  ysort_vector.assign(v.begin(), v.end());  
  int i,j;
  for(i=0;i<v.size()-1;i++){
    for(j=i;j<v.size();j++){
      
      if (xsort_vector[i].x() > xsort_vector[j].x()){
         std::swap(xsort_vector[i],xsort_vector[j]);
        }
      if (ysort_vector[i].y() > ysort_vector[j].y())
         std::swap(ysort_vector[i],ysort_vector[j]);
    }
  }
  p->setX(xsort_vector[0].x());
  p->setY(ysort_vector[0].y());
  *w = xsort_vector[v.size()-1].x() - xsort_vector[0].x();
  *h = ysort_vector[v.size()-1].y() - ysort_vector[0].y();
}
void DrawBase::drawBound(PixelBuffer* pb)
{
  Position2D bp = Position2D();
  PFLOAT bw,bh;
  findBound(&bp, &bw, &bh);
  int i,j;
  int x1 = bp.x();
  int x2 = bp.x() + bw;
  int y1 = bp.y();
  int y2 = bp.y() + bh;
  unsigned char* offset1 = (unsigned char*)pb->pixels + (y1 *  pb->bytesperline) + (pb->colors*x1);
  unsigned char* offset2 = (unsigned char*)pb->pixels + (y2 *  pb->bytesperline) + (pb->colors*x1);
  offset1--;
  offset2--;
  for(i=0;i<bw;i++){
    *(offset1++) = 128;
    *(offset1++) = 128; //G
    *(offset1++) = 128; //R
    *(offset2++) = 128;
    *(offset2++) = 128; //G
    *(offset2++) = 128; //R
  }
  for(j=0;j<bh;j++){
    offset1 = (unsigned char*)pb->pixels + ((j+y1) *  pb->bytesperline) + (pb->colors*x1);
    offset2 = (unsigned char*)pb->pixels + ((j+y1) *  pb->bytesperline) + (pb->colors*x2);
    *(offset1) = 128;
    *(offset1+1) = 128; //G
    *(offset1+2) = 128; //R
    *(offset2) = 128;
    *(offset2+1) = 128; //G
    *(offset2+2) = 128; //R
  }
}

void DrawBase::drawFill(PixelBuffer* pb)
{
  Position2D bp = Position2D();
  PFLOAT bw,bh;
  findBound(&bp, &bw, &bh);
  int i,j;
  int li = bp.x();
  int ri = bp.x()+bw;
  int uj = bp.y();
  int dj = bp.y()+bh;
  unsigned char b = 0x0000ff & color();
  unsigned char g = (0x00ff00 & color()) >> 8;
  unsigned char r = (0xff0000 & color()) >> 16;
  std::vector<Fomula1D> fomulas;
  Fomula1D fomula;
  int y2 = v[0].y();
  int x2 = v[0].x();
  int y1 = v[v.size()-1].y();
  int x1 = v[v.size()-1].x();
  double slop1 = double(y2-y1)/double(x2-x1);
  double bb1 = double(y2*x1-y1*x2)/double(x1-x2);
  fomula.slop = slop1;
  fomula.bias = bb1;
  fomulas.push_back(fomula);
  for(i=0;i<v.size()-1;i++){
    y2 = v[i+1].y();
    x2 = v[i+1].x();
    y1 = v[i].y();
    x1 = v[i].x();
    slop1 = double(y2-y1)/double(x2-x1);
    bb1 = double(y2*x1-y1*x2)/double(x1-x2);
    fomula.slop = slop1;
    fomula.bias = bb1;
    fomulas.push_back(fomula);
  }
  int k;
  //cal pos
  PFLOAT center_val = 1;
  for(k=0;k<fomulas.size();k++){
    center_val *= fomulas[k].slop*POS().x()+fomulas[k].bias-POS().y();
  }
  for(i=li;i<ri;i++){
    for(j=uj;j<dj;j++){
       PFLOAT check_val = 1;
       for(k=0;k<fomulas.size();k++){
        check_val *= fomulas[k].slop*i+fomulas[k].bias-j;
       }
       if (check_val*center_val > 0){
         unsigned char* offset = (unsigned char*)pb->pixels + (j *  pb->bytesperline) + (pb->colors*i);
         *offset = b;
         *(offset+1) = g; //G
         *(offset+2) = r; //R
       }
    }
  }
}

void Point::draw(PixelBuffer* pb)
{
  unsigned char b = 0x0000ff & color();
  unsigned char g = (0x00ff00 & color()) >> 8;
  unsigned char r = (0xff0000 & color()) >> 16;
  
  int li,ri,uj,dj;
  short posx = x();
  short posy = y();
  li = posx - size();
  ri = posx + size();
  uj = posy - size();
  dj = posy + size();
  
  if (li < 0) li = 0;
  if (ri > (pb->w-1)) ri = pb->w-1;
  if (uj < 0) uj = 0;
  if (dj > (pb->h-1)) dj = pb->h-1;
  
  int size2 = size()*size();
  int i,j;
  for(j=uj;j<dj;j++){
    for(i=li;i<ri;i++){
      int dist2 = (j-posy)*(j-posy)+(i-posx)*(i-posx);
      if (dist2 < size2){
        int dindex = (j *  pb->bytesperline) + (pb->colors*i);
        if (inBuffer(pb,i,j)){
          unsigned char* offset = (unsigned char*)pb->pixels + dindex;
          *offset = b;
          *(offset+1) = g; //G
          *(offset+2) = r; //R
        }
      }
    }
  } 
}
void Line::draw(PixelBuffer* pb)
{
  assert(v.size()==2);
  PFLOAT x0 =  v[0].x();
  PFLOAT y0 =  v[0].y();
  PFLOAT x1 =  v[1].x();
  PFLOAT y1 =  v[1].y();
  //
  bool is_swapxy = false;
  //
  unsigned char b = 0x0000ff & color();
  unsigned char g = (0x00ff00 & color()) >> 8;
  unsigned char r = (0xff0000 & color()) >> 16;
  //
  if (fabs(x1-x0) < fabs(y1-y0)){
    //We keep dx is longer than dy
    std::swap(x0,y0);
    std::swap(x1,y1);
    is_swapxy = true;
  }
  if (x0 > x1){
    // always keeo x0 < x1
    std::swap(x0,x1);
    std::swap(y0,y1);
  }
  //Try to cal step
  int dx = abs(x1-x0);
  int step = abs(y1-y0)*2;
  int steps = 0;
  int i;
  int j = y0;
  for(i=x0;i<x1;i++){
      if (is_swapxy){
        if (inBuffer(pb,j,i)){
          int dindex = (i *  pb->bytesperline) + (pb->colors*j);
          unsigned char* offset = (unsigned char*)pb->pixels + dindex;
          *offset = b;
          *(offset+1) = g; //G
          *(offset+2) = r;
        }
      }else{
        if (inBuffer(pb,i,j)){
          int dindex = (j *  pb->bytesperline) + (pb->colors*i);
          unsigned char* offset = (unsigned char*)pb->pixels + dindex;
          *offset = b;
          *(offset+1) = g; //G
          *(offset+2) = r;
        }
      }
      steps += step;
      if (steps > dx){
        steps -= dx*2;
        j += (y1>y0 ? 1:-1); 
      }
  }
}
/*
void Line::draw(PixelBuffer* pb)
{
  //size should be 2
  assert(v.size()==2);
  //printf("Draw LLine\n");
  unsigned char b = 0x0000ff & color();
  unsigned char g = (0x00ff00 & color()) >> 8;
  unsigned char r = (0xff0000 & color()) >> 16;
  short x2 = v[1].x();
  short x1 = v[0].x();
  short y2 = v[1].y();
  short y1 = v[0].y();
  //printf("(%d,%d)-(%d,%d), size=%f\n",x1,y1,x2,y2,size());
  if (x2 == x1){
    if (y2 < y1){
      int tmp = y2;
      y2 = y1;
      y1 = tmp;
      tmp = x2;
      x2 = x1;
      x1 = tmp;
    }
    int k;
    for(k=-size();k<size();k++){
      int j;
      for(j=y1;j<y2;j++){
        int i = x1+k;
        int dindex = (j *  pb->bytesperline) + (pb->colors*i);
        if (inBuffer(pb,i,j)){
          unsigned char* offset = (unsigned char*)pb->pixels + dindex;
          *offset = b;
          *(offset+1) = g; //G
          *(offset+2) = r;
        }
      }
    }
  }else{
    double slop = double(y2-y1)/double(x2-x1);
    //printf("slop %f\n", slop);
    double bb = double(y2*x1-y1*x2)/double(x1-x2);
    double abs_slop = abs(slop);
    int k;
    for(k=-size();k<size();k++){
      if (abs_slop < 1){
        //X>Y
        if (x2 < x1){
          int tmp = x2;
          x2 = x1;
          x1 = tmp;
          tmp = y2;
          y2 = y1;
          y1 = tmp;
        }
        int i;
        for(i=x1;i<x2;i++){
          int j = int((i*slop)+bb)+k;
          int dindex = (j *  pb->bytesperline) + (pb->colors*i);
          if (inBuffer(pb,i,j)){
            unsigned char* offset = (unsigned char*)pb->pixels + dindex;
            *offset = b;
            *(offset+1) = g; //G
            *(offset+2) = r;
          }
        }
      }else{
        //Y>X
        if (y2 < y1){
          int tmp = y2;
          y2 = y1;
          y1 = tmp;
          tmp = x2;
          x2 = x1;
          x1 = tmp;
        }
        int j;
        for(j=y1;j<y2;j++){
          int i = int((j-bb)/slop)-k;
          int dindex = (j *  pb->bytesperline) + (pb->colors*i);
          
          if (inBuffer(pb,i,j)){
            unsigned char* offset = (unsigned char*)pb->pixels + dindex;
            *offset = b;
            *(offset+1) = g; //G
            *(offset+2) = r;
          }
        }
      }
    }
  }
}
*/


void Triangle::draw(PixelBuffer* pb)
{
   assert(v.size()==3);
   if (fill()){
     drawFill(pb);  
   }else{
     Line l1 = Line(v[0], v[1],size(), color());
     Line l2 = Line(v[1], v[2],size(), color());
     Line l3 = Line(v[0], v[2],size(), color());
     //Line l1 = Line(v[0], v[1],size(), 0x00FF0000);
     //Line l2 = Line(v[1], v[2],size(), 0x0000FF00);
     //Line l3 = Line(v[0], v[2],size(), 0x000000FF);
     l1.draw(pb);
     l2.draw(pb);
     l3.draw(pb);
   }
   //drawBound(pb);
}

void Triangle::drawFill(PixelBuffer* pb)
{
  unsigned char b = 0x0000ff & color();
  unsigned char g = (0x00ff00 & color()) >> 8;
  unsigned char r = (0xff0000 & color()) >> 16;

  Position2D A =v[0];
  Position2D B =v[1];
  Position2D C =v[2];
  //find bounder
  int li = v[0].x();
  int ri = v[0].x();
  int dj = v[0].y();
  int uj = v[0].y();
  
  for (int i=1; i<v.size(); i++) { 
    li = std::max(0, std::min(li, (int)v[i].x()));
    ri = std::min((int)pb->w, std::max(ri, (int)v[i].x()));
    uj = std::max(0, std::min(uj, (int)v[i].y()));
    dj = std::min((int)pb->h, std::max(dj, (int)v[i].y()));
  }

  for (int j=uj; j<dj; j++) { 
    for (int i=li; i<ri; i++) { 
      //Cal cross dot
      Position2D P = Position2D(i,j);
      Position2D CA = C-A;
      Position2D BA = B-A;
      Position2D PA = A-P;
      SVector3 v3x = SVector3(CA.x(),BA.x(),PA.x());
      SVector3 v3y = SVector3(CA.y(),BA.y(),PA.y());
      SVector3 cross_dot;
      SVector3::crossProduct(v3x,v3y,cross_dot);
      if (cross_dot.z() == 0) continue;
      if (abs(cross_dot.z()) < 1) continue; //For Triangle
      SFLOAT u = cross_dot.x() /cross_dot.z();
      SFLOAT v = cross_dot.y() /cross_dot.z();
      SFLOAT uv_1 = 1.f - u - v;
      if ((uv_1 < 0) || (u < 0) || (v < 0)) continue;
      int dindex = (j *  pb->bytesperline) + (pb->colors*i);
      unsigned char* offset = (unsigned char*)pb->pixels + dindex;
      *offset = b;
      *(offset+1) = g; //G
      *(offset+2) = r;
    }
  }

}
/*
void Triangle::drawFill(PixelBuffer* pb)
{
  unsigned char b = 0x0000ff & color();
  unsigned char g = (0x00ff00 & color()) >> 8;
  unsigned char r = (0xff0000 & color()) >> 16;

  Position2D t0 =v[0];
  Position2D t1 =v[1];
  Position2D t2 =v[2];
  //sort Y
  if (t0.y() > t1.y())
    std::swap(t0,t1);
  if (t0.y() > t2.y())
    std::swap(t0,t2);
  if (t1.y() > t2.y())
    std::swap(t1,t2);

  int total_height = t2.y()-t0.y(); 
  for (int y=0; y<=total_height; y++) { 
    bool is_second_line = (y > (t1.y()-t0.y())) || (t1.y()==t0.y()) ;
    int segment_height = is_second_line ? (t2.y()-t1.y()+1) : (t1.y()-t0.y()+1);
    float alpha = (float)(y)/(float)(total_height); 
    float beta  = (float)(y-(is_second_line ? t1.y()-t0.y() : 0))/(float)(segment_height);
    Position2D A = t0 + (t2-t0)*alpha;
    Position2D B = is_second_line? t1 + (t2-t1)*beta : t0 + (t1-t0)*beta;
    if (A.x() > B.x())
      std::swap(A,B);
    for(int i=A.x();i<B.x();i++){
      int j = y + t0.y();
      int dindex = (j *  pb->bytesperline) + (pb->colors*i);
      unsigned char* offset = (unsigned char*)pb->pixels + dindex;
      *offset = b;
      *(offset+1) = g; //G
      *(offset+2) = r;
    }
  }
}
*/
void Rectangle::draw(PixelBuffer* pb)
{
   assert(v.size()==4);
   if (fill()){
     drawFill(pb);  
   }else{
     Position2D p0 = v[0];
     Position2D p1 = v[1];
     Position2D p2 = v[2];
     Position2D p3 = v[3];
     Line l1 = Line(p0, p1, size(), color());
     Line l2 = Line(p1, p2, size(), color());
     Line l3 = Line(p2, p3, size(), color());
     Line l4 = Line(p0, p3, size(), color());
     l1.draw(pb);
     l2.draw(pb);
     l3.draw(pb);
     l4.draw(pb);
   }
   //drawBound(pb);
}

void Plane3D::draw(PixelBuffer* pb)
{
  assert(v.size()==4);
  printf("Plane3D::draw\n");
  Position2D p0 = Position2D(v[0].x(),v[0].y());
  Position2D p1 = Position2D(v[1].x(),v[1].y());
  Position2D p2 = Position2D(v[2].x(),v[2].y());
  Position2D p3 = Position2D(v[3].x(),v[3].y());
  Point pt0 = Point(p0, 3, 0x000000FF);
  Point pt1 = Point(p1, 3, 0x0000FFFF);
  Point pt2 = Point(p2, 3, 0x0000FF00);
  Point pt3 = Point(p3, 3, 0x00FF00FF);
  pt0.draw(pb);
  pt1.draw(pb);
  pt2.draw(pb);
  pt3.draw(pb);
  Line l1 = Line(p0, p1, 1, 0x0000FF00);
  Line l2 = Line(p1, p2, 1, 0x0000FF00);
  Line l3 = Line(p2, p3, 1, 0x0000FF00);
  Line l4 = Line(p0, p3, 1, 0x0000FF00);
  l1.draw(pb);
  l2.draw(pb);
  l3.draw(pb);
  l4.draw(pb);

}

//void perspective_projection()
//{
  
//}

void Cube3D::draw(PixelBuffer* pb)
{
  assert(v.size()==8);
  assert(v2d.size()==8);
  //Point p = Point(Position2D(100,100),2,0x00FF0000);
  //p.draw(pb);
  int i;
  Position2D ps[8];
  for(i=0;i<8;i++){
    Position2D p = Position2D(v2d[i].x(),v2d[i].y());
    ps[i] = p;
  }
  //Draw line	
  Line l1 = Line(ps[0], ps[1], 1, 0x00FF0000);
  l1.draw(pb);
  Line l2 = Line(ps[1], ps[2], 1, 0x0000FF00);
  l2.draw(pb);
  Line l3 = Line(ps[2], ps[3], 1, 0x000000FF);
  l3.draw(pb);
  Line l4 = Line(ps[3], ps[0], 1, 0x00FFFFFF);
  l4.draw(pb);
  //
  Line l5 = Line(ps[4], ps[5], 1, 0x00FF0000);
  l5.draw(pb);
  Line l6 = Line(ps[5], ps[6], 1, 0x0000FF00);
  l6.draw(pb);
  Line l7 = Line(ps[6], ps[7], 1, 0x000000FF);
  l7.draw(pb);
  Line l8 = Line(ps[7], ps[4], 1, 0x00FFFFFF);
  l8.draw(pb);
  //
  Line l9 = Line(ps[0], ps[4], 1, 0x00FF0000);
  l9.draw(pb);
  Line l10 = Line(ps[1], ps[5], 1, 0x0000FF00);
  l10.draw(pb);
  Line l11 = Line(ps[2], ps[6], 1, 0x000000FF);
  l11.draw(pb);
  Line l12 = Line(ps[3], ps[7], 1, 0x00FFFFFF);
  l12.draw(pb);
}
